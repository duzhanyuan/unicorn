
/**
 * Copyright (c) 2011 Indian Institute of Technology, New Delhi
 * All Rights Reserved
 *
 * Entire information in this file and PMLIB software is property
 * of Indian Institue of Technology, New Delhi. Redistribution, 
 * modification and any use in source form is strictly prohibited
 * without formal written approval from Indian Institute of Technology, 
 * New Delhi. Use of software in binary form is allowed provided
 * the using application clearly highlights the credits.
 *
 * This work is the doctoral project of Tarun Beri under the guidance
 * of Prof. Subodh Kumar and Prof. Sorav Bansal. More information
 * about the authors is available at their websites -
 * Prof. Subodh Kumar - http://www.cse.iitd.ernet.in/~subodh/
 * Prof. Sorav Bansal - http://www.cse.iitd.ernet.in/~sbansal/
 * Tarun Beri - http://www.cse.iitd.ernet.in/~tarun
 */

#include "pmController.h"
#include "pmCommunicator.h"
#include "pmDevicePool.h"
#include "pmNetwork.h"
#include "pmMemoryManager.h"
#include "pmTaskManager.h"
#include "pmScheduler.h"
#include "pmDispatcherGPU.h"
#include "pmStubManager.h"
#include "pmLogger.h"
#include "pmCallbackUnit.h"
#include "pmCallback.h"
#include "pmAddressSpace.h"
#include "pmTask.h"
#include "pmSignalWait.h"
#include "pmRedistributor.h"
#include "pmSubscriptionManager.h"
#include "pmUtility.h"
#include "pmReducer.h"

namespace pm
{

pmController::pmController()
    : mLastErrorCode(0)
	, mFinalizedHosts(0)
    , mResourceLock __LOCK_NAME__("pmController::mResourceLock")
{
#ifdef ENABLE_ACCUMULATED_TIMINGS
    pmAccumulatedTimesSorter::GetAccumulatedTimesSorter();
#endif

    pmLogger::GetLogger();
    NETWORK_IMPLEMENTATION_CLASS::GetNetwork();
    TLS_IMPLEMENTATION_CLASS::GetTls();
    pmDispatcherGPU::GetDispatcherGPU();
    pmStubManager::GetStubManager();
    pmCommunicator::GetCommunicator();
    pmMachinePool::GetMachinePool();
    MEMORY_MANAGER_IMPLEMENTATION_CLASS::GetMemoryManager();
    pmTaskManager::GetTaskManager();
    pmScheduler::GetScheduler();
    pmTimedEventManager::GetTimedEventManager();
    pmHeavyOperationsThreadPool::GetHeavyOperationsThreadPool();

#ifdef DUMP_EVENT_TIMELINE
    pmStubManager::GetStubManager()->InitializeEventTimelines();
#endif
}

pmController* pmController::GetController()
{
    static pmController lController;
    static bool lFirstCall = true;
    
    if(lFirstCall)
    {
        NETWORK_IMPLEMENTATION_CLASS::GetNetwork()->GlobalBarrier();     
        lFirstCall = false;
    }

    return &lController;
}

void pmController::DestroyController()
{
    pmTaskManager::GetTaskManager()->WaitForAllTasksToFinish();
    NETWORK_IMPLEMENTATION_CLASS::GetNetwork()->FreezeReceptionAndFinishCommands(); // All commands are in scheduler queue after this stage and no more are generated by network
    pmScheduler::GetScheduler()->WaitForAllCommandsToFinish();
    pmStubManager::GetStubManager()->WaitForAllStubsToFinish();
    
    pmAddressSpace::DeleteAllLocalAddressSpaces();
}

void pmController::FinalizeController()
{
    const pmMachine* lMasterHost = pmMachinePool::GetMachinePool()->GetMachine(0);

    if(lMasterHost != PM_LOCAL_MACHINE)
    {
        pmScheduler::GetScheduler()->SendFinalizationSignal();

        finalize_ptr<communicator::hostFinalizationStruct> lBroadcastData(new communicator::hostFinalizationStruct(false));
        pmCommunicatorCommandPtr lBroadcastCommand = pmCommunicatorCommand<communicator::hostFinalizationStruct>::CreateSharedPtr(MAX_CONTROL_PRIORITY, communicator::BROADCAST, communicator::HOST_FINALIZATION_TAG, lMasterHost, communicator::HOST_FINALIZATION_STRUCT, lBroadcastData, 1);

        pmCommunicator::GetCommunicator()->Broadcast(lBroadcastCommand);
    }
    else
    {
        if(mSignalWait.get_ptr())
            PMTHROW(pmFatalErrorException());

        mSignalWait.reset(new SIGNAL_WAIT_IMPLEMENTATION_CLASS());

        pmScheduler::GetScheduler()->SendFinalizationSignal();
        
        mSignalWait->Wait();
    }

	DestroyController();
}

/* Only to be called on master controller (with mpi host id 0) */
void pmController::ProcessFinalization()
{
	FINALIZE_RESOURCE_PTR(dResourceLock, RESOURCE_LOCK_IMPLEMENTATION_CLASS, &mResourceLock, Lock(), Unlock());

	++mFinalizedHosts;
	if(mFinalizedHosts == NETWORK_IMPLEMENTATION_CLASS::GetNetwork()->GetTotalHostCount())
		pmScheduler::GetScheduler()->BroadcastTerminationSignal();
}

/* Only to be called on master controller (with mpi host id 0) */
void pmController::ProcessTermination()
{
	if(!mSignalWait.get_ptr())
		PMTHROW(pmFatalErrorException());
	
	mSignalWait->Signal();
}

/* Public API */
void pmController::RegisterCallbacks_Public(const char* pKey, pmCallbacks pCallbacks, pmCallbackHandle* pCallbackHandle)
{
    *pCallbackHandle = NULL;

	if(strlen(pKey) >= MAX_CB_KEY_LEN)
		PMTHROW(pmMaxKeyLengthExceeded);

    bool lSubtaskCB = (pCallbacks.subtask_cpu || pCallbacks.subtask_gpu_cuda || pCallbacks.subtask_gpu_custom);

	finalize_ptr<pmDataDistributionCB> lDataDistribution(pCallbacks.dataDistribution ? new pmDataDistributionCB(pCallbacks.dataDistribution) : NULL);
	finalize_ptr<pmSubtaskCB> lSubtask(lSubtaskCB ? new pmSubtaskCB(pCallbacks.subtask_cpu, pCallbacks.subtask_gpu_cuda, pCallbacks.subtask_gpu_custom) : NULL);
	finalize_ptr<pmDataReductionCB> lDataReduction(pCallbacks.dataReduction ? new pmDataReductionCB(pCallbacks.dataReduction) : NULL);
	finalize_ptr<pmDeviceSelectionCB> lDeviceSelection(pCallbacks.deviceSelection ? new pmDeviceSelectionCB(pCallbacks.deviceSelection) : NULL);
	finalize_ptr<pmDataRedistributionCB> lDataRedistributionCB(pCallbacks.dataRedistribution ? new pmDataRedistributionCB(pCallbacks.dataRedistribution) : NULL);
	finalize_ptr<pmPreDataTransferCB> lPreDataTransfer(pCallbacks.preDataTransfer ? new pmPreDataTransferCB(pCallbacks.preDataTransfer) : NULL);
	finalize_ptr<pmPostDataTransferCB> lPostDataTransfer(pCallbacks.postDataTransfer ? new pmPostDataTransferCB(pCallbacks.postDataTransfer) : NULL);

	*pCallbackHandle = new pmCallbackUnit(pKey, std::move(lDataDistribution), std::move(lSubtask), std::move(lDataReduction), std::move(lDeviceSelection), std::move(lDataRedistributionCB), std::move(lPreDataTransfer), std::move(lPostDataTransfer));

    NETWORK_IMPLEMENTATION_CLASS::GetNetwork()->GlobalBarrier();
}

void pmController::ReleaseCallbacks_Public(pmCallbackHandle pCallbackHandle)
{
	delete static_cast<pmCallbackUnit*>(pCallbackHandle);
}

void pmController::CreateMemory_Public(size_t pLength, pmMemHandle* pMem)
{
	*pMem = NULL;

    pmAddressSpace* lAddressSpace = pmAddressSpace::CreateAddressSpace(pLength, PM_LOCAL_MACHINE);
    *pMem = new pmUserMemHandle(lAddressSpace);
}

void pmController::ReleaseMemory_Public(pmMemHandle pMem)
{
    if(!pMem)
        PMTHROW(pmFatalErrorException());

	pmAddressSpace* lAddressSpace = (reinterpret_cast<pmUserMemHandle*>(pMem))->GetAddressSpace();

    delete (reinterpret_cast<pmUserMemHandle*>(pMem));
	lAddressSpace->UserDelete();
}

void pmController::FetchMemory_Public(pmMemHandle pMem)
{
    if(!pMem)
        PMTHROW(pmFatalErrorException());

	pmAddressSpace* lAddressSpace = (reinterpret_cast<pmUserMemHandle*>(pMem))->GetAddressSpace();
    
    lAddressSpace->Fetch(MAX_PRIORITY_LEVEL);
}

void pmController::FetchMemoryRange_Public(pmMemHandle pMem, size_t pOffset, size_t pLength)
{
    if(!pMem)
        PMTHROW(pmFatalErrorException());

	pmAddressSpace* lAddressSpace = (reinterpret_cast<pmUserMemHandle*>(pMem))->GetAddressSpace();
    
    lAddressSpace->FetchRange(MAX_PRIORITY_LEVEL, pOffset, pLength);
}
    
void pmController::GetRawMemPtr_Public(pmMemHandle pMem, void** pPtr)
{
    if(!pMem)
        PMTHROW(pmFatalErrorException());

	pmAddressSpace* lAddressSpace = (reinterpret_cast<pmUserMemHandle*>(pMem))->GetAddressSpace();
    *pPtr = lAddressSpace->GetMem();
}

void pmController::SubmitTask_Public(pmTaskDetails pTaskDetails, pmTaskHandle* pTaskHandle)
{
	*pTaskHandle = NULL;

    if(pTaskDetails.taskMemCount > MAX_MEM_SECTIONS_PER_TASK)
        PMTHROW(pmFatalErrorException());

	pmCallbackUnit* lCallbackUnit = static_cast<pmCallbackUnit*>(pTaskDetails.callbackHandle);

	if(pTaskDetails.taskConfLength == 0)
		pTaskDetails.taskConf = NULL;

    scheduler::schedulingModel lModel = scheduler::PUSH;
    if(pTaskDetails.policy != SLOW_START)
    {
        if(pTaskDetails.policy == RANDOM_STEAL)
            lModel = scheduler::PULL;
        else if(pTaskDetails.policy == EQUAL_STATIC)
            lModel = scheduler::STATIC_EQUAL;
        else if(pTaskDetails.policy == PROPORTIONAL_STATIC)
            lModel = scheduler::STATIC_PROPORTIONAL;
        else
            PMTHROW(pmFatalErrorException());
    }

    ushort lTaskFlags = 0;
    
    if(pTaskDetails.multiAssignEnabled)
        lTaskFlags |= TASK_MULTI_ASSIGN_FLAG_VAL;

    if(pTaskDetails.overlapComputeCommunication)
        lTaskFlags |= TASK_SHOULD_OVERLAP_COMPUTE_COMMUNICATION_FLAG_VAL;

    if(pTaskDetails.canSplitCpuSubtasks)
        lTaskFlags |= TASK_CAN_SPLIT_CPU_SUBTASKS_FLAG_VAL;
    
    if(pTaskDetails.canSplitGpuSubtasks)
        lTaskFlags |= TASK_CAN_SPLIT_GPU_SUBTASKS_FLAG_VAL;
    
    lTaskFlags |= TASK_CAN_FORCIBLY_CANCEL_SUBTASKS_FLAG_VAL;

    std::vector<pmTaskMemory> lTaskMemVector;
    lTaskMemVector.reserve(pTaskDetails.taskMemCount);
    for(size_t i = 0; i < pTaskDetails.taskMemCount; ++i)
    {
        pmAddressSpace* lAddressSpace = (reinterpret_cast<pmUserMemHandle*>(pTaskDetails.taskMem[i].memHandle))->GetAddressSpace();
        if(!lAddressSpace || pTaskDetails.taskMem[i].memType == MAX_MEM_TYPE)
            PMTHROW(pmFatalErrorException());
        
        pmTaskMem& pTaskMem = pTaskDetails.taskMem[i];
        lTaskMemVector.emplace_back(lAddressSpace, pTaskMem.memType, pTaskMem.subscriptionVisibilityType, pTaskMem.disjointReadWritesAcrossSubtasks);
    }
    
	*pTaskHandle = new pmLocalTask(pTaskDetails.taskConf, pTaskDetails.taskConfLength, pTaskDetails.taskId, std::move(lTaskMemVector), pTaskDetails.subtaskCount, lCallbackUnit, pTaskDetails.timeOutInSecs, PM_LOCAL_MACHINE, PM_GLOBAL_CLUSTER, pTaskDetails.priority, lModel, lTaskFlags);

	pmTaskManager::GetTaskManager()->SubmitTask(static_cast<pmLocalTask*>(*pTaskHandle));
}

void pmController::WaitForTaskCompletion_Public(pmTaskHandle pTaskHandle)
{
    if(!pTaskHandle)
        PMTHROW(pmFatalErrorException());

	(static_cast<pmLocalTask*>(pTaskHandle))->WaitForCompletion();
}

void pmController::ReleaseTask_Public(pmTaskHandle pTaskHandle)
{
    if(!pTaskHandle)
        PMTHROW(pmFatalErrorException());

	WaitForTaskCompletion_Public(pTaskHandle);
	static_cast<pmLocalTask*>(pTaskHandle)->UserDeleteTask();
}

void pmController::GetTaskExecutionTimeInSecs_Public(pmTaskHandle pTaskHandle, double* pTime)
{
    if(!pTaskHandle)
        PMTHROW(pmFatalErrorException());

	*pTime = (static_cast<pmLocalTask*>(pTaskHandle))->GetExecutionTimeInSecs();
}

void pmController::SubscribeToMemory_Public(pmTaskHandle pTaskHandle, pmDeviceHandle pDeviceHandle, ulong pSubtaskId, pmSplitInfo* pSplitInfo, uint pMemIndex, pmSubscriptionType pSubscriptionType, pmSubscriptionInfo& pSubscriptionInfo)
{
    pmSubtaskTerminationCheckPointAutoPtr lSubtaskTerminationCheckPointAutoPtr(static_cast<pmExecutionStub*>(pDeviceHandle));

    if(pSubscriptionType == READ_WRITE_SUBSCRIPTION)
    {
        (static_cast<pmTask*>(pTaskHandle))->GetSubscriptionManager().RegisterSubscription(static_cast<pmExecutionStub*>(pDeviceHandle), pSubtaskId, pSplitInfo, pMemIndex, READ_SUBSCRIPTION, pSubscriptionInfo);
        
        (static_cast<pmTask*>(pTaskHandle))->GetSubscriptionManager().RegisterSubscription(static_cast<pmExecutionStub*>(pDeviceHandle), pSubtaskId, pSplitInfo, pMemIndex, WRITE_SUBSCRIPTION, pSubscriptionInfo);
    }
    else
    {
        (static_cast<pmTask*>(pTaskHandle))->GetSubscriptionManager().RegisterSubscription(static_cast<pmExecutionStub*>(pDeviceHandle), pSubtaskId, pSplitInfo, pMemIndex, pSubscriptionType, pSubscriptionInfo);
    }
}

void pmController::RedistributeData_Public(pmTaskHandle pTaskHandle, pmDeviceHandle pDeviceHandle, ulong pSubtaskId, pmSplitInfo* pSplitInfo, uint pMemIndex, size_t pOffset, size_t pLength, uint pOrder)
{
    pmTask* lTask = static_cast<pmTask*>(pTaskHandle);
    const pmAddressSpace* lAddressSpace = lTask->GetAddressSpace(pMemIndex);
    
    lTask->GetRedistributor(lAddressSpace)->RedistributeData(static_cast<pmExecutionStub*>(pDeviceHandle), pSubtaskId, pSplitInfo, pOffset, pLength, pOrder);
}
    
void pmController::SetCudaLaunchConf_Public(pmTaskHandle pTaskHandle, pmDeviceHandle pDeviceHandle, ulong pSubtaskId, pmSplitInfo* pSplitInfo, pmCudaLaunchConf& pCudaLaunchConf)
{
    pmSubtaskTerminationCheckPointAutoPtr lSubtaskTerminationCheckPointAutoPtr(static_cast<pmExecutionStub*>(pDeviceHandle));

	(static_cast<pmTask*>(pTaskHandle))->GetSubscriptionManager().SetCudaLaunchConf(static_cast<pmExecutionStub*>(pDeviceHandle), pSubtaskId, pSplitInfo, pCudaLaunchConf);
}

void pmController::ReserveCudaGlobalMem_Public(pmTaskHandle pTaskHandle, pmDeviceHandle pDeviceHandle, ulong pSubtaskId, pmSplitInfo* pSplitInfo, size_t pSize)
{
    pmSubtaskTerminationCheckPointAutoPtr lSubtaskTerminationCheckPointAutoPtr(static_cast<pmExecutionStub*>(pDeviceHandle));

	(static_cast<pmTask*>(pTaskHandle))->GetSubscriptionManager().ReserveCudaGlobalMem(static_cast<pmExecutionStub*>(pDeviceHandle), pSubtaskId, pSplitInfo, pSize);
}

uint pmController::GetHostId_Public()
{
	if(!NETWORK_IMPLEMENTATION_CLASS::GetNetwork())
		PMTHROW(pmFatalErrorException());

	return NETWORK_IMPLEMENTATION_CLASS::GetNetwork()->GetHostId();
}

uint pmController::GetHostCount_Public()
{
	if(!NETWORK_IMPLEMENTATION_CLASS::GetNetwork())
		PMTHROW(pmFatalErrorException());

	return NETWORK_IMPLEMENTATION_CLASS::GetNetwork()->GetTotalHostCount();
}
    
void* pmController::GetScratchBuffer_Public(pmTaskHandle pTaskHandle, pmDeviceHandle pDeviceHandle, ulong pSubtaskId, pmSplitInfo* pSplitInfo, pmScratchBufferType pScratchBufferType, size_t pBufferSize)
{
    pmSubtaskTerminationCheckPointAutoPtr lSubtaskTerminationCheckPointAutoPtr(static_cast<pmExecutionStub*>(pDeviceHandle));
    
    return (static_cast<pmTask*>(pTaskHandle))->GetSubscriptionManager().GetScratchBuffer(static_cast<pmExecutionStub*>(pDeviceHandle), pSubtaskId, pSplitInfo, pScratchBufferType, pBufferSize);
    
    return NULL;
}

void pmController::pmReduceInts_Public(pmTaskHandle pTaskHandle, pmDeviceHandle pDevice1Handle, ulong pSubtask1Id, pmSplitInfo* pSplitInfo1, pmDeviceHandle pDevice2Handle, ulong pSubtask2Id, pmSplitInfo* pSplitInfo2, pmReductionType pReductionType)
{
    if(!pTaskHandle || !pDevice1Handle || !pDevice2Handle || pReductionType >= MAX_REDUCTION_TYPES)
        PMTHROW(pmFatalErrorException());

    (static_cast<pmTask*>(pTaskHandle))->GetReducer()->ReduceInts(static_cast<pmExecutionStub*>(pDevice1Handle), pSubtask1Id, pSplitInfo1, static_cast<pmExecutionStub*>(pDevice2Handle), pSubtask2Id, pSplitInfo2, pReductionType);
}

void pmController::pmReduceUInts_Public(pmTaskHandle pTaskHandle, pmDeviceHandle pDevice1Handle, ulong pSubtask1Id, pmSplitInfo* pSplitInfo1, pmDeviceHandle pDevice2Handle, ulong pSubtask2Id, pmSplitInfo* pSplitInfo2, pmReductionType pReductionType)
{
    if(!pTaskHandle || !pDevice1Handle || !pDevice2Handle || pReductionType >= MAX_REDUCTION_TYPES)
        PMTHROW(pmFatalErrorException());

    (static_cast<pmTask*>(pTaskHandle))->GetReducer()->ReduceUInts(static_cast<pmExecutionStub*>(pDevice1Handle), pSubtask1Id, pSplitInfo1, static_cast<pmExecutionStub*>(pDevice2Handle), pSubtask2Id, pSplitInfo2, pReductionType);
}

void pmController::pmReduceLongs_Public(pmTaskHandle pTaskHandle, pmDeviceHandle pDevice1Handle, ulong pSubtask1Id, pmSplitInfo* pSplitInfo1, pmDeviceHandle pDevice2Handle, ulong pSubtask2Id, pmSplitInfo* pSplitInfo2, pmReductionType pReductionType)
{
    if(!pTaskHandle || !pDevice1Handle || !pDevice2Handle || pReductionType >= MAX_REDUCTION_TYPES)
        PMTHROW(pmFatalErrorException());

    (static_cast<pmTask*>(pTaskHandle))->GetReducer()->ReduceLongs(static_cast<pmExecutionStub*>(pDevice1Handle), pSubtask1Id, pSplitInfo1, static_cast<pmExecutionStub*>(pDevice2Handle), pSubtask2Id, pSplitInfo2, pReductionType);
}

void pmController::pmReduceULongs_Public(pmTaskHandle pTaskHandle, pmDeviceHandle pDevice1Handle, ulong pSubtask1Id, pmSplitInfo* pSplitInfo1, pmDeviceHandle pDevice2Handle, ulong pSubtask2Id, pmSplitInfo* pSplitInfo2, pmReductionType pReductionType)
{
    if(!pTaskHandle || !pDevice1Handle || !pDevice2Handle || pReductionType >= MAX_REDUCTION_TYPES)
        PMTHROW(pmFatalErrorException());

    (static_cast<pmTask*>(pTaskHandle))->GetReducer()->ReduceULongs(static_cast<pmExecutionStub*>(pDevice1Handle), pSubtask1Id, pSplitInfo1, static_cast<pmExecutionStub*>(pDevice2Handle), pSubtask2Id, pSplitInfo2, pReductionType);
}

void pmController::pmReduceFloats_Public(pmTaskHandle pTaskHandle, pmDeviceHandle pDevice1Handle, ulong pSubtask1Id, pmSplitInfo* pSplitInfo1, pmDeviceHandle pDevice2Handle, ulong pSubtask2Id, pmSplitInfo* pSplitInfo2, pmReductionType pReductionType)
{
    if(!pTaskHandle || !pDevice1Handle || !pDevice2Handle || pReductionType >= MAX_REDUCTION_TYPES)
        PMTHROW(pmFatalErrorException());

    (static_cast<pmTask*>(pTaskHandle))->GetReducer()->ReduceFloats(static_cast<pmExecutionStub*>(pDevice1Handle), pSubtask1Id, pSplitInfo1, static_cast<pmExecutionStub*>(pDevice2Handle), pSubtask2Id, pSplitInfo2, pReductionType);
}

void pmController::MapFile_Public(const char* pPath)
{
    if(strlen(pPath) > MAX_FILE_SIZE_LEN - 1)
        PMTHROW(pmFatalErrorException());

    pmUtility::MapFileOnAllMachines(pPath);
}

void* pmController::GetMappedFile_Public(const char* pPath)
{
    return pmUtility::GetMappedFile(pPath);
}
    
void pmController::UnmapFile_Public(const char* pPath)
{
    if(strlen(pPath) > MAX_FILE_SIZE_LEN - 1)
        PMTHROW(pmFatalErrorException());

    pmUtility::UnmapFileOnAllMachines(pPath);
}

} // end namespace pm
